# -*- mode: org; org-confirm-babel-evaluate: nil; org-babel-noweb-wrap-start: "«"; org-babel-noweb-wrap-end: "»"; -*-
#+TITLE: Découvrons Java
#+AUTHOR: Bernard Hugueney

#+LANGUAGE: fr
#+LANG: fr

#+BEGIN_SRC elisp :exports none :results silent
 (setq org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar")
(org-babel-do-load-languages
 'org-babel-load-languages
 '((ditaa . t)
   (java . t)))
#+END_SRC



* Un arôme de Java

Java est un langage de [[https://fr.wikipedia.org/wiki/Programmation_orient%25C3%25A9e_objet][Programmation Orientée Objet]]. Nous verrons plus tard ce que cela signifie, mais pour l'instant, ce qui est important c'est que Java ne se contente pas de /permettre/ la programmation orientée objet, il l'impose, contrairement à python qui, lui nous a permis d'écrire de petit scripts, voir d'exécuter des bouts de code sans fioritures.

Java a été conçu pour une utilisation professionnelle en entreprise et nombreuses de ses caractéristiques, non seulement ce qu'il permet mais aussi ce qu'il empêche (par exemple d'écrire de simples petits bouts de code[fn::Ceci est un peu moins vrai depuis la sortie de [[https://en.wikipedia.org/wiki/JShell][JShell]], mais les principes du langage Java restent inchangés.]).

Ainsi, le moindre programme Java exige :
- de choisir un nom pour l'/unité de code/ (une /classe/, cf. infra) que l'on va écrire, par exemple "Exercice1"[fn::les minuscules et majuscules, ainsi que le fait de coller les mots sont importants ! Cf. [[https://fr.wikipedia.org/wiki/Camel_case][CamelCase]]]
- de créer un fichier portant exactement ce nom et l'extension ~.java~.
- d'écrire dans ce fichier le code ci-dessous :

#+BEGIN_SRC java :exports code
public class Exercice1 {
    public static void main(String[] args){
	/*
	  Écrire ici le code à exécuter
	*/
    }
}
#+END_SRC

src_java[:exports code]{/* et */} délimitant un bloc de commentaires (src_java[:exports code]{// indiquant un commentaire jusqu'à la fin de la ligne}, comme src_python[:exports code]{# en python}).

** Java, un langage compilé

Alors qu'il suffisait de passer en argument le fichier contenant du code en python à l'interpréteur Python, il n'en est pas de même pour Java. En effet, il y a une phase intermédiaire : la compilation.

#+BEGIN_SRC ditaa :file img/pythonInterpreterFr.png

    +------------+   +--------------+    +---------+
    | Fichier(s) |   | interpréteur |    |exécution|
    |  de code   | --+    python    +--->|   du    |
    | en python  |   |              |    |programme|
    |     {d}    |   |       {io}   |    |         |
    +------------+   +--------------+    +---------+

#+END_SRC

#+RESULTS:
[[file:pythonInterpreterFr.png]]
#+BEGIN_SRC ditaa :file img/javaCompilerFr.png

    +----------+   +-----------+    +-------------+   +----------+   +---------+
    |Fichier(s)|   |compilateur|    | Fichier(s)  |   |  machine |   |exécution|
    | de code  | --+   java    +--->|exécutable(s)| --+ virtuelle+-->|   du    |
    | en Java  |   |  (javac)  |    | de bytecode |   |   java   |   |programme|
    |    {d}   |   |    {io}   |    |        {d}  |   |    {io}  |   |         |
    +----------+   +-----------+    +-------------+   +----------+   +---------+

#+END_SRC

#+RESULTS:
[[file:img/javaCompilerFr.png]]


Cette décomposition en deux étapes distinctes (compilation puis
exécution) a évidemment des avantages (performance et surtout
fiabilité, cf. infra.) mais lorsqu'on développe un programme en Java,
on passe son temps à écrire du code et à l'exécuter et l'on a pas
envie de devoir répéter la même séquence en lançant à chaque fois le
programme ~javac~ (pour compiler) puis le programme ~java~ (pour
exécuter). Pour cette raison, les /environnements de développement
intégrés/ (/IDE/ en anglais) réalise automatiquement la phase de
compilation lorsqu'on clique sur le bouton /Run/ [fn::ou évidemment
lorsqu'on utilise le raccourci clavier équivalent] qui est une flèche
verte sous /IntelliJ/ et une flèche blanche dans un rond vert sous
/Eclipse/.


* Premier programme Java
Pour bien comprendre comment fonctionnent l'édition la compilation et
le lancement d'un programme java, on va d'abord effectuer les différentes étapes avec différents programmes (un éditeur de texte, le compilateur ~javac~, le programme ~java~ qui lance la machine virtuelle java (JVM), en mode console. Ensuite, on utilisera un Environnement de Développement Intégré (IDE).


** En mode "console"

Éditer un fichier texte avec le contenu suivant :
#+BEGIN_SRC java :tangle Exercice1.java :exports code
public class Exercice1 {
    public static void main(String[] args){
	System.out.println("Hello World!");
    }
}
#+END_SRC

Comme indiqué plus haut, il ne faut pas s'inquiéter si les couleurs ne sont pas les mêmes : il s'agit juste de [[https://fr.wikipedia.org/wiki/Coloration_syntaxique][Coloration syntaxique]].

Le compiler en utilisant le programme ~javac~ :
#+BEGIN_SRC shell :exports code
javac Exercice1.java
#+END_SRC

Pour que la commande ~javac~ soit utilisable, il faut :

1. avoir installé le [[https://fr.wikipedia.org/wiki/Java_Development_Kit][Java Development Kit]] (JDK) à ne pas confondre avec le [[https://fr.wikipedia.org/wiki/Environnement_d%2527ex%25C3%25A9cution_Java][Java Runtime Environment]] (JRE) qui ne contient que ~java~ et non ~javac~. On s'assurera d'avoir au moins la version 8 de java.
2. avoir fait en sorte que les programmes exécutables ~javac~ et ~java~ soient reconnus comme commandes (par exemple en [[https://www.java.com/fr/download/help/path.xml][ajustant la variable d'environnement PATH]]).

On peut constater que le résultat de la compilation est la création du fichier ~.class~ correspondant au fichier ~.java~ :
#+BEGIN_SRC shell :exports both
ls -l Exercice1.*
#+END_SRC

#+RESULTS:
| -rw-r--r-- | 1 | bernard | bernard | 424 | Sep | 28 | 20:47 | Exercice1.class |
| -rw-r--r-- | 1 | bernard | bernard | 114 | Sep | 28 | 20:46 | Exercice1.java  |


- Exercice :: Regarder quelles sont les arguments optionnels du
              programme ~javac~ et essayer d'en utiliser quelques uns.

L'exécuter en utilisant le programme ~java~ :
#+BEGIN_SRC shell :exports both
java Exercice1
#+END_SRC

*Attention !* L'argument du programme ~java~ est le nom de la *classe*
(tel qu'indiqué dans le fichier source à la ligne src_java[:exports code]{public class Exercice1}), il n'y a donc pas d'extension de nom de fichier (ni ~.class~ ni -encore moins!- ~.java~).

Normalement, l'exécution produit l'affichage suivant :
#+RESULTS:
: Hello World!

*Attention !* Un /fichier texte/ doit être créé/édité avec un *éditeur
de texte* (comme Notepad sous Windows) et non pas un *traitement de
texte*. Si l'affichage montre parfois des couleurs, celles-ci sont
automatiquement générées et ne sont pas stockées dans le /fichier
source/ qui ne contient que du texte brut, sans indications de police
de caractères, formatage ou colorisation.

- Exercices ::  
  - Édition du code :: Modifier le programme pour qu'il affiche autre
       chose (par exemple ~Bonjour tout le monde !~). Recompiler et
       relancer le programme.
  - Changement du nom de la classe :: Faire un autre programme, dans
       une classe appelée par exemple ~Exercice2~, qui fasse la même
       chose. Compiler et lancer ce nouveau programme.


** Avec un IDE

Lancer son IDE (Eclipse ou IntelliJ) et choisir dans les menus ~File~ → ~New~ → ~Project…~ ou ~Java Project~.

[[file:img/IntelliJ-new-project.png]]

Puis, le répertoire ~src~ de ce projet étant sélectionné dans
l'arborescence de projets (par défaut à gauche de la fenêtre),
sélectionner ~New~ → ~Java Class~ ou ~Class~ dans le menu contextuel
(bouton droit).

[[file:img/IntelliJ-new-class.png]]

Choisir un nom de classe, par exemple ~ExerciceIde1~, en laissant le nom de /package/ vide (cf. infra), et éditer le code pour avoir un programme (donc avec un src_java[:exports code]{public static void main(String[] args)}) qui fasse un affichage (donc avec un src_java[:exports code]{System.out.println(/* ce qu'on veut afficher/*);}).

** Un début d'explications

Dans tout ce qu'il faut écrire pour avoir un programme en Java, la
plupart des mots-clés nécessitent des concepts qui ne seront abordés
que plus tard. On peut néanmoins expliquer l'argument ~args~ de
src_java[:exports code]{public static void main(String[] args)}. Il
s'agit d'un argument de fonction, comme on a pu les voir en python. À
la différence de python, pour un argument, ici ~args~, on ne se contente pas de mettre le nom de l'argument (on aurait bien sûr pu choisir n'importe quel autre nom légal comme ~arguments~ ou ~programArguments~), mais on préfixe le ou les arguments par leur /type/, ici src_java[:exports code]{String[]}. Ici, on sait donc que l'argument est un tableau de chaînes de caractères.

On peut modifier le code compilé et exécuté en ligne comme ci-après :
#+BEGIN_SRC java :exports code :tangle ExampleArgs.java
public class ExampleArgs{
    public static void main(String[] args){
	System.out.print("Hello ");
	System.out.println(args[0]);
    }
}
#+END_SRC

(~ExampleArgs~ plutôt que ~ExempleArgs~ n'est pas une faute de
frappe : il est bon de programmer /in English/ et autant s'y mettre
aussi tôt que possible !)

On peut ensuite compiler ce programme :
#+BEGIN_SRC shell :exports code :results none
javac ExampleArgs.java
#+END_SRC

Et l'exécuter avec un argument pour afficher le résultat attendu :
#+BEGIN_SRC shell
java ExampleArgs Yall
#+END_SRC

#+RESULTS:
: Hello Yall

*Attention !* Si l'on veut passer un argument contenant un espace (ou autre caractère séparateur), il faut utiliser des guillemets. De même si l'on veut utiliser des caractères qui ont un sens particulier pour l'interpréteur de commandes de la console :

#+BEGIN_SRC shell
java ExampleArgs "you all !"
#+END_SRC

#+RESULTS:
: Hello you all !

- Exercices ::  
  - Compréhension de code :: comprendre la différence entre src_java[:exports code]{System.out.print();} et src_java[:exports code]{System.out.println();}.
  - Test de code :: Lancer le programme avec moins ou plus qu'un argument.
  - Connaissance de l'IDE :: Modifier le programme écrit avec l'IDE
       pour qu'il utilise aussi l'argument de src_java[:exports
       code]{public static void main(String[] args)}. Configurer le
       lancement du programme (sous IntelliJ avec le menu ~Run~ →
       ~Edit Configurarions~ par exemple) pour définir le ou les
       arguments passés au lancement du programme par l'IDE.
  - Modification de code :: Pour un programme développé en mode
       console et pour un programme développée avec l'IDE, changer le
       nom de la classe (par exemple de src_java[:exports code]{public
       class ExampleArgs} à src_java[:exports code]{public class
       ExampleArgsRenamed}), en faisant en sorte de toujours pouvoir
       lancer le programme !

* Conventions

En France, *techniquement* on peut rouler à gauche. En pratique, on impose des contraintes par le code de la route, afin que les automobilistes puissent partager la route sans avoir à se concerter à chaque fois pour faire émerger un consensus local. Il en va de même pour le développement informatique, qui comporte des /conventions/ parce qu'il met en jeu des équipes de développement. Ainsi, on aurait pu *techniquement* appeler notre classe src_java[:exports code]{example_args} mais la convention *impose* de respecter le [[https://fr.wikipedia.org/wiki/Camel_case][CamelCase]] en commençant par une majuscule pour un nom de classe en Java.

De même pour l'indentation qui, si elle n'est pas fixée par le langage Java lui-même (contrairement à Python), est [[https://google.github.io/styleguide/javaguide.html#s4-formatting][imposée par convention]]. Les IDE permettent de formater automatiquement le code, par exemple sous IntelliJ avec le menu ~Code~ → ~Reformat Code~ ou le raccourci clavier équivalent ~Ctrl~ + ~Alt~ + ~L~.

* Variables et typage

En Java, on va pouvoir définir des variables, qui correspondent à un
emplacement mémoire auquel on donne un nom, qui est accessible par un
certain code et qui peut stocker *un certain type de valeurs*.

** Variables locales

Dans un premier temps, on s'intéressera uniquement à ce que l'on
appelle des /variables locales/. Ces variables ne sont accessibles
(n'existent !) qu'à l'intérieur du bloc de code dans lequel elles sont
déclarées. La restriction de l'accès est un /avantage/ lorsqu'il
s'agit de pouvoir décomposer le code pour pouvoir raisonner sur une
partie isolée du code sans avoir à ce préoccuper de tout ce qui
pourrait interagir avec lui.


Les arguments des fonctions, comme l'argument src_java[:exports
code]{String[] args} de src_java[:exports code]{public static void
main(String[] args)}, sont des variables locales, dont la valeur est
initialisée à l'appel de la fonction, par la valeur correspondante (en
cas de liste de plusieurs arguments, selon la position) passée lors de
l'appel de la fonction (pour ~main~, c'est un cas particulier car la
fonction est appelée par la JVM et les arguments sont passés par le
système d'exploitation au lancement du programme.

** Typage statique

Comme on a pu le constater avec l'argument src_java[:exports
code]{String[] args} de src_java[:exports code]{public static void
main(String[] args)}, les variables sont déclarées non seulement avec
un nom, mais aussi avec un type.

Par exemple, le bout de code suivant déclare et initialise trois variables locales:
#+BEGIN_SRC java :exports code
boolean formateur = true;
int age = 30;
String prenom = "Jules";
#+END_SRC

Remarque : on peut déclarer des variables sans les initialiser, mais ce n'est pas forcément (euphémisme) une bonne idée.

- Exercice :: Dans un programme Java, effectuer les déclarations sans
              initialisations ci-dessous. Que peut-on observer ?
              Essayer d'afficher le contenu de ces variables non
              initialisées. Que se passe-t-il ?
  #+BEGIN_SRC java :exports code
boolean formateur;
int age;
String prenom;
  #+END_SRC


Un type définit la /nature/ des valeurs stockables dans cette
variable, qui détermine l'ensemble des valeurs représentables et les
opérations qu'il est possible de faire sur ces valeurs.

 Le fait que ce type soit immuable (les variables ne changent pas de type au cours de l'exécution du programme) et connu à la compilation constitue le /typage statique/ qui permet de vérifier /avant le lancement du programme/ que les types sont corrects. Essayer d'ajouter la ligne suivante à l'intérieur d'une fonction src_java[:exports code]{public static void main(String[] args)}:
#+BEGIN_SRC java :exports code
args[0]= 1;
#+END_SRC

Dans un développement en mode console, c'est à la compilation qu'on aurait une erreur :
#+BEGIN_EXAMPLE
ExampleArgs.java:5: error: incompatible types: int cannot be converted to String
        args[0]= 1;
                 ^
1 error

#+END_EXAMPLE

Dans un IDE, la ligne est immédiatement soulignée en rouge et un
indicateur rouge apparaît dans la marge à gauche.

- Exercice :: Dans un programme Java développé sous un IDE, écrire les
              déclarations des variables ~formateur~, ~age~ et
              ~prenom~ vues plus haut. Écrire ensuite les affectations
              suivantes :
              #+BEGIN_SRC java :exports code
formateur = "Bernard";
age = 44.2;
prenom = 'a';    
	      #+END_SRC
	      Essayer aussi de faire des affectations entre types
              primitifs numériques, entre types entiers et types à
              virgule, et entre types de taille différentes.

* Types de données primitifs

Java définit [[https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html][un certain nombre de types]] dits /primitifs/. 

** Types numériques

Il y a deux catégories de types primitifs numériques, suivant qu'on
cherche à représenter des nombres entiers ou à virgules. Dans chacune
de ces catégories, les différents types correspondent à différentes
tailles en mémoire et permette de choisir le compromis entre encombrement mémoire et nombres de valeurs différentes représentables : on peut représenter au maximum 2^N valeurs différentes avec N bits.

*** Types entiers
En java, tous les types entiers sont dit /signés/, c'est-à-dire qu'ils peuvent représenter des valeurs positives ou négatives et utilisent la représentation binaire du /complément à deux/ qui représente une valeur de plus strictement négative que strictement positive (dit autrement, autant de valeurs < 0 que de valeurs  >= 0).

- byte :: défini sur 8 bits
- short :: défini sur 16 bits
- int :: défini sur 32 bits
- long :: défini sur 64 bits

Lorsqu'on écrit une valeur entière directement dans le code (par exemple src_java[:exports code]{43210}, sont type est src_java[:exports code]{int}. On peut utiliser le suffixe ~L~ (~l~ est légal mais déconseillé pour sa ressemblance avec ~1~) pour indiquer que la valeur doit être de type src_java[:exports code]{long}.


*Attention !* Les opérateurs arithmétiques de base (~+~, ~-~, ~*~, ~/~) sont tous définis comme produisant un résultat de même type, donc *entier*. Quel est donc le résultat de src_java[:exports code]{5/2} ? Que se passe-t-il si l'on a des opérandes de différents types numériques ? Faire des hypothèses et les tester.

- Exercice ::   
  - Compréhension :: Pour chaque type entier, calculer (ou trouver sur
                     internet et comprendre !) les valeurs minimale et
                     maximale qu'il est possible de représenter.
  - Écriture / exécution de code :: Pour chaque type entier, essayer
       de dépasser les valeurs minimale ou maximale soit directement à
       l'initialisation d'une variable, soit par une opération (par
       exemple en ajoutant ou en retranchant ~1~).



*** Types à virgule

Il est essentiel de bien comprendre que l'on ne peut évidemment pas représenter tous les nombres à virgule dans un ordinateur, puisqu'il y en a une infinité même entre 0 et 1 !

Il y a deux types primitifs de nombres à virgule qui correspondent à
deux compromis sur l'encombrement mémoire et la précision & plage des
valeurs représentables, selon la [[https://fr.wikipedia.org/wiki/IEEE_754][norme IEEE754]] de représentation en
mémoire.

- float :: codés sur 32 bits
- double :: codés sur 64 bits

Il y aura donc forcément un risque d'arrondis dont [[https://dzone.com/articles/never-use-float-and-double-for-monetary-calculatio][il faut se méfier]]. Aussi, le fait que les valeurs soient stockée en binaire trompe notre intuition sur le nombre de chiffres nécessaires pour représenter une valeur à virgule et Java ne nous aide pas en arrondissant lors des affichages de ces valeurs. Ainsi, lorsqu'on écrit ~0.1~, il faut avoir conscience que l'ordinateur ne peut stocker que la valeur la plus proche possible, à savoir 


~0.1000000000000000055511151231257827021181583404541015625~ pour le type src_java[:exports code]{double} et ~0.100000001490116119384765625~ pour le type src_java[:exports code]{float}.


Lorsqu'on écrit une valeur à virgule [fn:: avec un point ~.~ et non une virgule ~,~ comme séparateur décimal !] son type est src_java[:exports code]{double}. On peut utiliser le suffixe ~f~ ou ~F~ Pour que le type soit src_java[:exports code]{float}.


** Type booléen 

En java, le type booléen est src_java[:exports code]{boolean} et les valeurs s'écrivent src_java[:exports code]{true} et src_java[:exports code]{false}.

** Type caractère

En java, le type des caractères est src_java[:exports
code]{char}. *Attention !* la standardisation de Java date des
anciennes version d'[[https://fr.wikipedia.org/wiki/Unicode][Unicode]] qui ne codaient les caractères que sur 16
bits (deux octets). En conséquence, [[https://laethy.developpez.com/tutoriels/java/jvm/unicode-et-java/][certains graphèmes nécessitent 2
caractères]] en Java pour être représentés.

Les caractères sont représentés entre guillemets *simples* en utilisant des séquences commençant par /backslash/ pour représenter les caractères spéciaux :
#+BEGIN_SRC java :exports code
char letter = 'a';
char newLine = '\n';
char tab = '\t';
#+END_SRC

* Types de données gérés par référence
Alors que les types primitifs  que l'on vient de voir sont stockés directement en mémoire "dans" les variables, les types que l'on va maintenant voir sont stockés indirectement, les variables "contenant" une /référence/ (on parle aussi parfois de pointeur, il s'agit en fait de l'adresse en mémoire où est stockée la valeur elle-même). Cette distinction aura beaucoup de conséquences très importantes. Lorsqu'une référence n'est pas initialisée, elle a une valeur spéciale src_java[:exports code]{null}. Essayer d'utiliser une référence valant ~null~ comme si elle était une référence valide vers une valeur en mémoire provoquera une [[https://en.wikipedia.org/wiki/Null_pointer#Null_dereferencing][erreur classique]] qu'on devra éviter.


** Types tableaux

On a vu un exemple de tableau avec l'argument de src_java[:exports code]{public static void main(String[] args)}. Un type de tableau est toujours un tableau du type de chacune des cases du tableau (elles sont toutes du même type !), par exemple ici src_java[:exports code]{String[]} est un tableau de cases de type src_java[:exports code]{String} (qu'on abordera juste après).

Quelques exemples de déclarations de tableaux :
#+BEGIN_SRC java :exports code
int[] arrayOfInts; // (référence vers un) tableau d'ints
long[] arrayOfLongs; // (référence vers un) tableau de longs
float[] arrayOfFloats;// (référence vers un) tableau de floats
double[] arrayOfDoubles;// (référence vers un) tableau de floats
#+END_SRC

On remarque que la taille ne fait pas partie du type tableau. On sait que src_java[:exports code]{int[] arrayOfInts} est un tableau d'entiers [fn:: plus précisément une référence vers un tableau d'entiers], mais on ne sait pas de quelle taille. Après ces déclarations, les variables contiennent des références invalides car il n'y aucun tableau créé :

#+BEGIN_SRC ditaa :file img/ref-array-0.png
arrayOfInts
arrayOfLongs
arrayOfFloats
arrayOfDoubles
#+END_SRC

#+attr_html: :width 200px
#+attr_latex: :width 100px
#+RESULTS:
[[file:img/ref-array-0.png]]


Il est important de comprendre que ces déclarations sans initialisation en créent pas de tableau : il n'y a alors aucun tableau en mémoire, juste des références pour l'instant invalides. On peut initialiser un tableau de différentes façons :
- En écrivant directement dans le code les valeurs du tableau entre
  accolades, séparées par des virgules :
  #+BEGIN_SRC java :exports code
arrayOfDoubles = {0.5, 5.0, -0.75};
arrayOfDoubles = {1., -1.,}; // la taille n'est pas la même
  #+END_SRC
  À la première affectation, on a :
  #+BEGIN_SRC ditaa :file img/ref-array-1.png :cmdline -E
arrayOfDoubles-+
       +-------+
       |
       v
+----+---+---+
|0.5 |5.0| 0 |
+----+---+---+
  #+END_SRC
  #+attr_html: :width 500px
  #+attr_latex: :width 100px
  #+RESULTS:
  [[file:img/ref-array-1.png]]
  Puis à la deuxième :
  #+BEGIN_SRC ditaa :file img/ref-array-2.png :cmdline -E
arrayOfDoubles-+
               |
               |
               |
+----+---+---+ |
|0.5 |5.0| 0 | |
+----+---+---+ |
               |
     +---------+
     |
     v
+----+----+
|1.0 |-1.0|
+----+----+
  #+END_SRC
  #+attr_html: :width 500px
  #+attr_latex: :width 100px
  #+RESULTS:
  [[file:img/ref-array-2.png]]

Lorsqu'une valeur en mémoire n'est plus référencée, elle ne peut plus être utilisée et la JVM libère la mémoire que cette valeur occupait grâce à un mécanisme appelé [[https://fr.wikipedia.org/wiki/Ramasse-miettes_(informatique)][ramasse-miettes]] (/garbage collector/ in English).
- En indiquant le nombre de case (par une expression, qui peut donc
  être calculée dynamiquement [fn:: pour rappel, dynamiquement veut
  dire /à l'exécution/.]). Les cases sont alors remplies avec la
  valeur par défaut du type considéré :
  #+BEGIN_SRC java :exports code
arrayOfDoubles = new double[2 + 1];
  #+END_SRC
  Si l'on effectue cette troisième affectation à la suite des précédentes, on a:
  #+BEGIN_SRC ditaa :file img/ref-array-3.png :cmdline -E
arrayOfDoubles-+
               |
               |
+----+---+---+ |
|0.5 |5.0| 0 | |
+----+---+---+ |
               |
+----+----+    |
|1.0 |-1.0|    |
+----+----+    |
         +-----+
         | 
         v
+-----+-----+-----+
| 0.0 | 0.0 | 0.0 |
+-----+-----+-----+
  #+END_SRC

  #+attr_html: :width 500px
  #+attr_latex: :width 100px
  #+RESULTS:
  [[file:img/ref-array-3.png]]

Il est important de comprendre que chaque affectation en modifie pas le tableau, ni pour changer son contenu, ni pour changer sa taille, mais affecte la référence sur un autre tableau.

- Exercice ::  
  - Trouver de l'information et/ou codage exploratoire :: Trouver
       quelles sont les valeurs par défaut des différents types
       primitifs.
  - Codage exploratoire :: Passer des variables de type tableau en
       argument de src_java[:exports code]{System.out.println()}. Quel
       sens donner à l'affichage obtenu ?

** Accès aux éléments d'un tableau

On utilise la notation src_java[:exports code]{nomDuTableau[valeurindice]} pour accéder à la case d'indice ~valeurindice~ du tableau ~nomDuTableau~. Les indices commencent à ~0~, donc un tableau de taille ~1~ aura une seule valeur d'indice légale, la valeur ~0~.

- Exercice :: Que ce passe-t-il lorsque l'on essaie d'accéder à un
              tableau qui n'a pas été initialisé ? Lorsqu'on essaie
              d'accéder à une case dont l'indice est trop grand (>= à
              la taille du tableau) ou trop petit (< 0)?
** Accès à la taille du tableau
Pour un tableau donné, on peut accéder à sa taille avec la notation src_java[:exports code]{nomDuTableau.length}. La taille est de type src_java[:exports code]{int}.

- Exercice :: Quelle est la taille maximale d'un tableau en Java ?

** Tableau de tableaux

On peut avoir un type de tableau pour n'importe quel type de
cases. Pour un type src_java[:exports code]{X}, on peut avoir le type
src_java[:exports code]{X[]} /tableau de X/. Par exemple
src_java[:exports code]{int[]} est le type /tableau d'entiers/. On
peut donc avoir des tableaux de tableaux par exemple src_java[:exports
code]{int[][]} est le type /tableau de tableaux d'entiers/.

*** Déclaration
Avec une simple déclaration, il n'y a *aucun* tableau en mémoire.
#+BEGIN_SRC java :exports code
int[][] data;
#+END_SRC

#+BEGIN_SRC ditaa :file img/ref-array2d-0.png :cmdline  -E
data
#+END_SRC

#+attr_html: :width 100px
#+attr_latex: :width 50px
#+RESULTS:
[[file:img/ref-array2d-0.png]]

*** Initialisation partielle
Si l'on ne crée qu'un seul tableau, il n'y a qu'un tableau qui *pourra* contenir des références vers des tableaux.
#+BEGIN_SRC java :exports code
int[][] data= new int[2][];
#+END_SRC

#+BEGIN_SRC ditaa :file img/ref-array2d-1.png :cmdline  -E
data -+
      |
      v
   +-----+
   |     |
   +-----+
   |     |
   +-----+
#+END_SRC

#+attr_html: :width 200px
#+attr_latex: :width 100px
#+RESULTS:
[[file:img/ref-array2d-1.png]]

*** Initialisation 
Il faut initialiser chacune des cases de tableau de tableaux.
#+BEGIN_SRC java :exports code
int[][] data= {{1,0},{2,-1,0}};
#+END_SRC

#+BEGIN_SRC ditaa :file img/ref-array2d-2.png :cmdline -E
data -+
      |
      v
   +-------+     +---+---+
   |data[0]|---->| 1 | 0 |
   +-------+     +---+---+
   |data[1]|-+
   +-------+ |  +---+---+---+
             +->| 2 |-1 | 0 |
                +---+---+---+
#+END_SRC

#+attr_html: :width 1000px
#+attr_latex: :width 200px
#+RESULTS:
[[file:img/ref-array2d-2.png]]


** Type chaîne de caractères

On a vu avec l'argument de src_java[:exports code]{public static void
main(String[] args)} que le type /chaîne de caractères/ est
src_java[:exports code]{String}. La majuscule en début de nom,
contrairement aux noms de types primitifs comme src_java[:exports
code]{int}, src_java[:exports code]{boolean} ou src_java[:exports
code]{float}, est importante car elle indique qu'il s'agit du nom
d'une /classe/, comme les classes que nous sommes obligés de définir
pour écrire un programme en Java.

On écrit une chaîne de caractères dans le code Java en l'entourant de guillemets doubles : src_java[:exports code]{"Une chaîne de caractères"}. Si cette chaîne doit contenu un guillemet double, il faut l'échapper avec une [[https://fr.wikipedia.org/wiki/Barre_oblique_invers%25C3%25A9e][barre oblique inversée]] (antislash, ou /backslash/) : src_java[:exports code]{"une chaîne avec un \" au milieu"}.

Les chaînes de caractères sont manipulées par référence, ce qui fait qu'affecter la contenu d'une variable de type /chaîne de caractères/ à une autre variable ne crée pas une copie de la chaîne de caractères mais juste une nouvelle référence vers la même chaîne de caractères : on dit que ces chaînes ne sont pas seulement /égales/, mais /identiques/. En pratique, cela ne crée pas de problèmes car les chaînes de caractères sont /immuables/, c'est-à-dire qu'on ne peut pas modifier leur valeur.

Les opérations qu'il est possible d'effectuer sur une chaîne de caractères sont définies dans la [[https://docs.oracle.com/javase/9/docs/api/java/lang/String.html][classe String]]. En plus, il est possible de [[https://fr.wikipedia.org/wiki/Concat%25C3%25A9nation#Programmation][concaténer]] des chaînes de caractères avec l'opérateur src_java[:exports code]{+}.

Une autre particularité des chaînes de caractères est que les valeurs des autres types peuvent être transformées automatiquement en chaînes de caractères lorsque cela est nécessaire. C'est grâce à ce mécanisme qu'on peut par exemple passer n'importe quel type en argument de System.out.println(), par exemple src_java[:exports code]{System.out.println(32);}, et concaténer n'importe quelle valeur à une chaîne de caractères, par exemple src_java[:exports code]{"Nombre de joueurs: "+ 2}.

- Exercice :: Comparer les résultats de src_java[:exports
              code]{"score: " + 2 + 3} et src_java[:exports code]{2 +
              3 +"points"}.

** Tous les autres types définissables (classes)

On peut définir de nouveau types comme String en définissant de nouvelles classes. Ce que nous verrons dans le cadre de la /Programmation Orientée Objet/.


* Structures de contrôle
On peut exécuter des blocs d'instructions de façon conditionnelle
et/ou répétée grâce aux /structures de contrôle/. En java, on retrouve l'équivalent de celles vues en python. Particulièrement lorsque l'on a programmé en python, il faut faire attention :
- au fait que les blocs de code sont délimités par des accolades ~{~
  et ~}~ et non par l'indentation et qu'il n'y a pas de ~:~ pour
  marquer le début de bloc.
- au fait que les blocs sont théoriquement optionnels et qu'en
  l'absence de bloc explicite, la structure de contrôle porte sur une
  seule instruction.
- que l'instruction vide ~;~ est une instruction valide ! (qui ne fait rien)

** Exécution conditionnelle

*** Expression booléennes

Une expression booléenne élémentaire est souvent réalisée avec un
opérateur de comparaison : ~<~, ~>~, ~<=~, ~>=~, ~!=~, ~==~.

- Exercice :: Faire un programme qui affiche des résultats de
              comparaisons. Quelle est la valeur de src_java[:exports
              code]{0.3 == (3*0.1)} ? Pourquoi ?


On peut composer des expressions booléennes à l'aide d'opérateurs logiques :
- && :: ET logique dont le résultat est src_java[:exports code]{true}
        si et seulement si les deux opérandes valent src_java[:exports
        code]{true}.
- || :: OU logique dont le résultat est src_java[:exports code]{true}
        si un moins un des opérandes (l'un ou l'autre ou les deux!)
        vaut src_java[:exports code]{true}.
- ^ :: OU EXCLUSIF dont le résultat est src_java[:exports code]{true}
       si un et un seul un des opérandes vaut src_java[:exports
       code]{true}.

- Exercices ::  

  - Codage exploratoire ::  Écrire un petit programme qui met en œuvre
       les opérateurs logiques.

  - Compréhension :: Que fait le bout de code suivant ? [[https://en.wikipedia.org/wiki/Short-circuit_evaluation][Comment]] ? Pourquoi ?
  #+BEGIN_SRC java :exports code
int idx = -1;
boolean[] data = {true, false, true};
boolean win = (idx >=0 ) && data[idx];
boolean fail = data[idx] && (idx >= 0);
  #+END_SRC



*** if
#+BEGIN_SRC java :exports code
if (expressionBooleenne){
    /*
      Code à exécuter si la valeur de
      expressionBooleenne est true
     */
}
#+END_SRC
#+BEGIN_SRC java :exports code
if (expressionBooleenne){
    /*
      Code à exécuter si la valeur de
      expressionBooleenne est true
     */
}else{
    /*
      Code à exécuter si la valeur de
      expressionBooleenne est false
     */
}
#+END_SRC

- Exercice :: Écrire un petit programme qui met en œuvre la structure
              de contrôle src_java[:exports code]{if} avec plusieurs
              instructions exécutées conditionnellement. Que se
              passe-t-il l'on oublie les accolade ou si l'on ajoute un
              ~;~ : src_java[:exports
              code]{if(uneExpressionBoolenne);} avant le bloc.
*** Opérateur ternaire

On a vu des opérateurs binaires, arithmétiques et logiques, qui ont
donc deux arguments. Il existe un opérateur particulier, l'opérateur
ternaire, qui prend trois arguments, séparés donc par deux symboles
~?~ et ~:~, sous la forme src_java[:exports code]{ expressionBooleenne
? expressionSiVraie : expressionSiFausse}. L'évaluation de
l'expression commence par évaluer l'~expressionBooleenne~. Si et
seulement si cette expression est vraie, alors l'~expressionSiVraie~
est évaluée et constitue la valeur de l'expression ternaire. Sinon,
alors seule l'expression ~expressionSiFausse~ est évaluée et constitue
la valeur de l'expression ternaire. L'expression booléenne doit être
de type booléen. Les deux autres expressions peuvent être de n'importe
quel type qui constitue donc le type de l'expression ternaire.

- Exercice ::  
  - Écriture de de code :: Écrire un programme qui utilise un opérateur ternaire.
  - Compréhension :: Que fait le code suivant ? Pourquoi ?
  #+BEGIN_SRC java :exports code
boolean[] data = {true, false, false, true, true};
int idx = -1;
System.out.println( (idx >= 0) ? data[idx] : false);
  #+END_SRC

*** switch

Parfois, on veut comparer la valeur d'une expression avec un ensemble
de valeurs connues pour exécuter différents blocs de code en fonction
de la valeur. Par exemple :
#+BEGIN_SRC java :export code
public static long arithmeticOp(long i, long j, char op){
    long res=0;
    if (op == '-'){
	res = i - j;
    } else if (op == '+'){
	res = i + j;
    } else if (op == '*'){
	res = i * j;
    }else if (op == '/'){
	res = i / j;
    }else{
	System.err.println("Operation "+ op + "inconnue !!!");
    }
    return res;
}
#+END_SRC

Même si le fait de ne pas ouvrir un nouveau bloc pour chaque
src_java[:exports code]{else} ne contenant qu'un seul
src_java[:exports code]{if} permet d'éviter de s'enfoncer dans les
niveaux d'indentation, il est fastidieux de répéter le
src_java[:exports code]{else if (op == …)}.

Pour éviter ces répétitions, Java possède une structure de contrôle
dédiée : le src_java[:export code](switch).

Le code précédent s'écrirait avec un src_java[:export
code](switch). de la façon suivante :
#+BEGIN_SRC java :export code
public static long arithmeticOp(long i, long j, char op){
    long res=0;
    switch (op){
    case '-':{
	res = i - j;
	break;
    }
    case '+':{
	res = i + j;
	break;
    }
    case '*':{
	res = i * j;
	break;
    }
    case '/':{
	res = i / j;
	break;
    }
    default:{
	System.err.println("Operation "+ op + "inconnue !!!");
    }
    }
    return res;
}
#+END_SRC

L'expression testée doit être d'un type entier, ou de type
src_java[:exports code]{char}, ou de type src_java[:exports
code]{String}.

- Exercice :: Faire tourner un programme utilisant la fonction
              src_java[:exports code]{arithmeticOp}. Que se passe-t-il
              si l'on enlève les instructions src_java[:exports
              code]{break;} ? À quoi sert-elle ? Ajouter la gestion de
              l'opérateur modulo pour le caractère ~%~.

** Boucles while(){} et do{} while();
Lorsque des opérations doivent être répétées plusieurs fois,
éventuellement 0 ou 1 fois au minimum, on peut
utiliser,respectivement, les structures de contrôle suivantes :

- while :: qui effectue le test avant de (re)commencer éventuellement exécuter le bloc de code
	   #+BEGIN_SRC java :exports code
while(expressionBooleenne){
    /*
      corps de la boucle : instructions à répéter
    */
}
	   #+END_SRC
- do while :: qui effectue le test après avoir exécuté (donc au moins
              une fois) le bloc d'instruction, pour recommencer
              éventuellement.
	      #+BEGIN_SRC java :exports code
do{
    /*
      corps de la boucle : instructions à répéter
    */
}while(expressionBoolenne);
	      #+END_SRC

Lorsqu'on veut que la boucle puisse s'arrêter (et généralement on le
veut !), on doit s'assurer que la condition de répétition puisse être
modifiée par l'exécution du corps de la boucle !

- Exercice :: Que se passe-t-il lorsque l'on exécute les codes
              suivants (src_java[:exports code]{%} est l'opérateur
              [[https://fr.wikipedia.org/wiki/Modulo_(op%25C3%25A9ration)][modulo]] qui calcule le reste de la division entière) ?
              Pourquoi ?
	      #+BEGIN_SRC java :exports code
int v = 192;
int compteur = 0;
while (v % 2 == 0)
    System.out.println("le compteur vaut "+ compteur + " car "+ v+ " est (encore) pair");
    v = v / 2;
    compteur = compteur + 1;
System.out.println("le nombre était divisible "+ compteur + " fois par 2";
	      #+END_SRC
   
	      #+BEGIN_SRC java :exports code
int v = 192;
int compteur = 0;
while (v % 2 == 0);
{
    System.out.println("le compteur vaut "+ compteur + " car "+ v+ " est (encore) pair");
    v = v / 2;
    compteur = compteur + 1;
}
System.out.println("le nombre était divisible "+ compteur + " fois par 2";
	      #+END_SRC

** Boucles for(;;){} et for( : ){}
*** Boucle for classique
Souvent, la condition de continuation est liée à une variable
initialisée juste avant et dont la valeur est mise à jour à la fin du
bloc répété. Par exemple, pour afficher dix chiffres à partir de 0 :
#+BEGIN_SRC java :exports code
int compteur = 0;
while(compteur < 10){
    System.out.println(compteur);
    compteur = compteur + 1; // on pourrait écrire compteur += 1 ou même ++compteur
}
#+END_SRC

De façon générale :
#+BEGIN_SRC java :exports code
/*
initialisation
*/
while(testDeContinuation){
    /*
      instructions à répéter
    */
    /*
      mise à jour pour l'itération suivante
     */
}
#+END_SRC


La structure de contrôle ~for~ "classique"[fn::depuis la version 5,
Java a ajouté une nouvelle boucle ~for~ similaire à son homologue
python, cf. infra] permet justement de regrouper ces trois éléments :
#+BEGIN_SRC java :exports code
for(initialisation ; testDeContinuation; miseAJourPourLIterationSuivante){
    /*
      instructions à répéter
    */
}
#+END_SRC

La boucle affichant les dix chiffres à partir de 0 s'écrira donc :
#+BEGIN_SRC java :exports code
for(int compteur = 0; compteur < 10; ++compteur){ // ++compteur est ici équivalent à compteur = compteur + 1
    System.out.println(compteur);
}
#+END_SRC

De même que pour les boucles src_java[:exports code]{while()} et
src_java[:exports code]{do while();}, il faut généralement s'assurer
que la condition de continuation soit modifiée, normalement au niveau
de la partie "mise à jour pour l'itération suivante" de la boucle
src_java[:exports code]{for()}.

- Exercices :: 
  - Écrire un programme qui affichage les nombres de 9 à 0 inclus.
  - Écrire un programme qui calcule et affiche combien de fois un
    nombre, par exemple ~192~ est divisible par 2.

*** Boucle for sur une séquence de valeurs

Lorsqu'on veut traiter toutes les valeurs d'un tableau, par exemple
pour les afficher, on peut utiliser une boucle src_java[:exports
code]{while} ou une boucle src_java[:exports code]{for} classique :
- boucle while ::  
		  #+BEGIN_SRC java :exports code
int[] data = {1, 2, 0, -1, 4, 8};
int i = 0;
while(i != data.length){
    System.out.println(data[i]);
    ++i;
}
		  #+END_SRC
- boucle for classique ::   
		  #+BEGIN_SRC java :exports code
int[] data = {1, 2, 0, -1, 4, 8};
for(int i = 0; i != data.length; ++i){
    System.out.println(data[i]);
}
		  #+END_SRC
		  Que se passe-t-il si l'on essaie d'utiliser la
     variable src_java[:exports code]{i} après la boucle ? Noter la différence avec la boucle
     src_java[:exports code]{while}.


Ce cas de figure est suffisamment fréquent pour qu'une version
spécifique de boucle src_java[:exports code]{for} ait été ajoutée au
langage Java, avec la même fonctionnalité qu'en Python :
#+BEGIN_SRC java :exports code
for(TypeElement element : collectionElements){
    /*
      code utilisant la variable element qui prend successivement chacune des valeurs de collectionElements
     ,*/
}
#+END_SRC

Par exemple :
		  #+BEGIN_SRC java :exports code
int[] data = {1, 2, 0, -1, 4, 8};
for(int v : data){
    System.out.println(v);
}
		  #+END_SRC

* Fonctions
On va vouloir décomposer son code en unités minimales qui réalise un
calcul ou une tâche, de façon paramétrée. La /fonction/ [fn::en
/Programmation Orientée Objet/, notamment en Java, on parle de
méthodes, ici statiques ou "de classe". Cf. cours sur la POO], qui
prend éventuellement des arguments et retourne éventuellement une
valeur, est l'unité de décomposition du code. On a vu un cas
particulier de fonction avec celle qui implémente le programme
principal : src_java[:exports code]{public static void main(String[]
args)}. Dans un premier temps, on ne s'attardera pas sur
src_java[:exports code]{public static} qu'on reproduira à l'identique
pour toutes nos fonctions. src_java[:exports code]{void main(String[]
args)} indique que l'on définit une fonction appelée src_java[:exports
code]{main} qui prend en argument src_java[:exports code]{String[]
args}, donc un tableau de chaînes de caractères appelé
src_java[:exports code]{args}, et ne retourne rien (src_java[:exports
code]{void}).


Les fonctions permettent de décomposer le code d'une application
notamment parce que les variables sont /locales/ : on peut donc
raisonner localement sans avoir à se demander s'il y a du code
ailleurs qui pourrait influencer / être influencé par la valeur des
variables utilisées dans la fonction.

** Instruction ~return~

Le bloc d'instructions qui définit une fonction peut contenir zéro,
une ou plusieurs instructions src_java[:exports code]{return}.


Le seul cas où il peut n'y avoir aucun instruction return dans le
corps d'une fonction est celui des fonctions ne retournant aucun
valeur (ce qui est indiqué par le mot clé src_java[:exports
code]{void} à la place du type de retour, comme dans src_java[:exports
code]{public static void main(String[] args)}. Dans ce cas, tout se
passe comme s'il y avait une instruction src_java[:exports
code]{return;} après la dernière instruction du bloc définissant la
fonction. Par exemple :
#+BEGIN_SRC java :exports code
public static void main(String[] args){
    System.out.println("Hello World !");
}
#+END_SRC
et équivalent à :
#+BEGIN_SRC java :exports code
public static void main(String[] args){
    System.out.println("Hello World !");
    return;
}
#+END_SRC

Dans tous les autres cas, il faut que l'exécution du code d'une
fonction indiquant retourner une valeur d'un certain type aboutisse à
l'exécution d'une instruction src_java[:exports code]{return
expressionDuTypeAttendu;}. Par exemple :
#+BEGIN_SRC java :exports code
public static double cmToInches(double inCm){
    double inInches = inCm * 0.394;
    return inInches;
}
#+END_SRC
Cet exemple utilise une variable locale src_java[:exports code]{double
inInches} pour montrer explicitement le type de la valeur retournée,
mais on aurait pu écrire directement :

#+BEGIN_SRC java :exports code
public static double cmToInches(double inCm){
    return inCm * 0.394; // l'expression inCm * 0.394 est de type double
}
#+END_SRC

Lorsqu'une instruction src_java[:exports code]{return} est exécutée,
le flux d'exécution quitte immédiatement la fonction. S'il y avait des
instructions après l'instruction src_java[:exports code]{return},
elles ne seraient jamais exécutées. Mais le compilateur (ou l'IDE)
signale un erreur lorsqu'on essaie d'écrire un tel code.

- Exercice :: Écrire la fonction src_java[:exports code]{cmToInches}
              dans un IDE et ajouter du code (par exemple
              src_java[:exports code]{System.out.println("Je ne peux
              pas être exécutée!");} *après* l'instruction
              src_java[:exports code]{return}. Que se passe-t-il ?


Le corps d'une fonction peut contenir plusieurs instructions
src_java[:exports code]{return}, lorsqu'une instruction de contrôle de
flux d'exécution (par exemple un src_java[:exports code]{if}) produit
des chemins d'exécution exclusifs. Par exemple :

#+BEGIN_SRC java :exports code
public static long fibonacci(long n){
    if(n <= 2){
	return n;
    }// on pourrait avoir un else
    return fibonacci(n-1) + fibonacci(n-2);
}
#+END_SRC

** Passage d'argument

Une fonction peut avoir zéro, un, ou plusieurs arguments, indiqués,
avec leur type, entre parenthèses et séparés par des virgules :
#+BEGIN_SRC java :exports code
public static void fonctionAvecZeroArg(){
    /*
      corps de la fonction
    ,*/
}
public static void fonctionAvecUnArg(int seulArgument){
    /*
      corps de la fonction
    ,*/
}

public static void fonctionAvecDeuxArgs(String premierArgument, float secondArgument){
    /*
      corps de la fonction
    ,*/
}
public static void fonctionAvecTroisArgs(boolean premierArgument, int[] secondArgument, double troisiemeArgument){
    /*
      corps de la fonction
    ,*/
}
#+END_SRC


Lors de l'appel d'une fonction, le flux d'exécution quitte la fonction
appelante pour exécuter le corps de la fonction appelée.  Soit le
programme suivante, avec une fonction principale src_java[:exports
code]{public static void main(String[] args)} qui appelle une fonction
src_java[:exports code]{public static double cmToInchesArea(double
widthInCm, double lengthInCm)}. Cette dernière est à la fois fonction
appelée (par la fonction principale) et fonction appelante, faisant
deux appels à la fonction src_java[:exports code]{public static double
cmToInches(double inCm)} :
#+BEGIN_SRC java :exports code
public class Main{
  public static void main(String[] args){
    double res =  cmToInchesArea(10.5, 5.0);   
    System.out.println(res);
  }
  public static double cmToInches(double inCm){
    double inInches = inCm * 0.394;
    return inInches;
  }
  public static double cmToInchesArea(double widthInCm
                                    , double lengthInCm){
    double widthInInches = cmToInches(widthInCm);
    double lengthInInches = cmToInches(lengthInCm);
    return widthInInches * lengthInInches;
  }
}
#+END_SRC

On peut visualiser son exécution pas à pas [[http://www.pythontutor.com/visualize.html#code=public%2520class%2520Main%257B%250A%2520%2520public%2520static%2520void%2520main%2528String%255B%255D%2520args%2529%257B%250A%2520%2520%2520%2520double%2520res%2520%253D%2520%2520cmToInchesArea%252810.5,%25205.0%2529%253B%2520%2520%2520%250A%2520%2520%2520%2520System.out.println%2528res%2529%253B%250A%2520%2520%257D%250A%2520%2520public%2520static%2520double%2520cmToInches%2528double%2520inCm%2529%257B%250A%2520%2520%2520%2520double%2520inInches%2520%253D%2520inCm%2520*%25200.394%253B%250A%2520%2520%2520%2520return%2520inInches%253B%250A%2520%2520%257D%250A%2520%2520public%2520static%2520double%2520cmToInchesArea%2528double%2520widthInCm%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520,%2520double%2520lengthInCm%2529%257B%250A%2520%2520%2520%2520double%2520widthInInches%2520%253D%2520cmToInches%2528widthInCm%2529%253B%250A%2520%2520%2520%2520double%2520lengthInInches%2520%253D%2520cmToInches%2528lengthInCm%2529%253B%250A%2520%2520%2520%2520return%2520widthInInches%2520*%2520lengthInInches%253B%250A%2520%2520%257D%250A%257D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=java&rawInputLstJSON=%255B%255D&textReferences=false][en ligne]].

 - Exercice :: Sous IDE, éditer le code précédent et l'exécuter /pas à
               pas/ en mode /debug/. Pour cela, cliquer dans la marge
               à gauche du code au niveau de la ligne
               src_java[:exports code]{public static void
               main(String[] args)} (bouton gauche sous IntelliJ, menu
               contextuel sous Eclipse) pour y poser un point d'arrêt
               (/breakpoint/). Lancer l'exécution en mode /debug/ (par
               exemple en cliquant sur le bouton avec un insecte
               vert). Ensuite, exécuter le code /pas à pas/ en entrant
               dans les fonctions appelées (/step into/), par exemple
               en cliquant sur la flèche vers le bas sous IntelliJ.

[[file:img/IntelliJ-debug.png]]

** Contexte local d'exécution / pile / fonction récursive

En fait, même si les variables locales sont considérées comme
"appartenant" à la fonction dans laquelle elles sont déclarées, les
espaces mémoire correspondant sont plus précisément liés au /contexte
local d'exécution/ de la fonction lorsqu'elle est appelée. Cela veut
dire que de nouvelles variables sont crées à chaque appel de la
fonction. La nuance est importante lorsqu'une fonction est appelée
plusieurs fois "en même temps", le plus souvent dans le cadre d'appels
récursifs (d'où les guillemets à "en même temps"). Une fonction
récursive s'appelle elle-même, elle est donc à la fois appelante
d'elle-même et appelée par elle-même. À chaque appel de fonction, les
variables locales de la fonction appelée sont crées et à chaque retour
de la fonction appelée, ces variables locales sont détruites. En
pratique, ces variables sont crées dans une /pile/ car ce sont
toujours les dernières crées qui sont les premières détruites puisque
la prochaine fonction de laquelle on va retourner est toujours la
dernière fonction qu'on a appelée.

Pour se convaincre de l'importance du contexte local d'exécution,
considérer les fonctions suivantes :

- Simple récursion, [[http://www.pythontutor.com/visualize.html#code=public%2520class%2520Main%257B%250A%2520%2520public%2520static%2520void%2520main%2528String%255B%255D%2520args%2529%257B%250A%2520%2520%2520%2520long%2520res%2520%253D%2520factorial%25284%2529%253B%250A%2520%2520%2520%2520System.out.println%2528res%2529%253B%250A%2520%2520%257D%250A%2520%2520public%2520static%2520long%2520factorial%2528long%2520n%2529%257B%250A%2520%2520%2520%2520if%2528n%2520%253C%25202%2529%257B%250A%2520%2520%2520%2520%2520%2520return%25201%253B%250A%2520%2520%2520%2520%257D//%2520on%2520pourrait%2520avoir%2520un%2520else%250A%2520%2520%2520%2520long%2520res%2520%253D%2520n%2520*%2520factorial%2528n-1%2529%253B%250A%2520%2520%2520%2520return%2520%2520res%253B%250A%2520%2520%257D%250A%257D%250A&cumulative=false&curInstr=27&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=java&rawInputLstJSON=%255B%255D&textReferences=false][dont on peut visualiser l'exécution en ligne]] :
  #+BEGIN_SRC java :exports code
public class Main{
  public static void main(String[] args){
    long res = factorial(4);
    System.out.println(res);
  }
  public static long factorial(long n){
    if(n < 2){
      return 1;
    }// on pourrait avoir un else
    long res = n * factorial(n-1);
    return  res;
  }
}
  #+END_SRC

- Double récursion, [[http://www.pythontutor.com/visualize.html#code=public%2520class%2520Main%257B%250A%2520%2520public%2520static%2520void%2520main%2528String%255B%255D%2520args%2529%257B%250A%2520%2520%2520%2520long%2520res%2520%253D%2520fibonacci%25284%2529%253B%250A%2520%2520%2520%2520System.out.println%2528res%2529%253B%250A%2520%2520%257D%250A%2520%2520public%2520static%2520long%2520fibonacci%2528long%2520n%2529%257B%250A%2520%2520%2520%2520if%2528n%2520%253C%253D%25202%2529%257B%250A%2520%2520%2520%2520%2520%2520return%2520n%253B%250A%2520%2520%2520%2520%257D//%2520on%2520pourrait%2520avoir%2520un%2520else%250A%2520%2520%2520%2520long%2520res%2520%253D%2520fibonacci%2528n-1%2529%253B%250A%2520%2520%2520%2520res%2520%253D%2520res%2520%252B%2520fibonacci%2528n-2%2529%253B%250A%2520%2520%2520%2520return%2520%2520res%253B%250A%2520%2520%257D%250A%257D&cumulative=false&curInstr=30&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=java&rawInputLstJSON=%255B%255D&textReferences=false][dont on peut visualiser l'exécution en ligne]] :

  #+BEGIN_SRC java :exports code
public class Main{
  public static void main(String[] args){
    long res = fibonacci(4);
    System.out.println(res);
  }
  public static long fibonacci(long n){
    if(n <= 2){
      return n;
    }// on pourrait avoir un else
    long res = fibonacci(n-1);
    res = res + fibonacci(n-2);
    return  res;
  }
}
  #+END_SRC

*Attention !* On veut toujours que des appels récursifs "s'arrêtent" à
un moment donné. Il doit donc toujours y avoir (au moins) une
/condition d'arrêt/ dépendant de la valeur des arguments et les appels
récursifs doivent faire converger les valeurs des arguments vers la
conditions d'arrêt.

- Exercices ::  
  - Compréhension de code :: Pour les fonctions récursives, vérifier
       si elles s'arrêtent effectivement.
  - Avoir un modèle mental d'exécution :: Exécuter dans sa tête, pas à
       pas, les programmes précédents.
  - Utiliser un IDE ::  Exécuter dans un IDE, pas à pas, les
       programmes précédents.
  - Comprendre les messages d'erreur :: Supprimer les conditions
       d'arrêt des fonctions récursives précédentes et les
       exécuter. Que veut dire le message d'erreur ?


** Surcharge de fonctions

Une fonction d'une classe est identifiée par sa /signature/ qui doit
être unique. Celle-ci est définie non seulement par le nom de la
fonction, mais aussi par les arguments (nombre, types) de la
fonction. On peut donc définir plusieurs fonctions ayant le même
nom. Par exemple :
#+BEGIN_SRC java :export code
public static String arrayToString(int[] array){
    String res = "[";
    for(int i = 0; i != array.length; ++i){
	res = res + " "+ array[i];
    }
    return res +"]";
}

public static String arrayToString(double[] array){
    String res = "[";
    for(double v : array){
	res += " " + v;
    }
    return res +"]";
}
#+END_SRC

Cela ne pose pas de problème à Java grâce au typage /statique/ : en
effet, à chaque appel de fonction, Java connaît le type des arguments
et peut donc choisir l'implémentation ayant la signature correspondante.

- Exercices :  
  - Implémentation :: Ajouter des implémentations pour les signatures
                      suivantes : src_java[:exports
                      code]{arrayToString(String[] array)},
                      src_java[:exports code]{arrayToString(boolean[]
                      array)}.
  - Algorithme :: Modifier les implémentations de src_java[:exports
                  code]{arrayToString} pour séparer les valeurs par
                  src_java[:exports code]{", "} (une virgule puis un
                  espace). On ne veut pas de séparateur avant la
                  première valeur, ni après la dernière valeur !


* Références Webliographiques
Quelques liens pour trouver des informations ou faire de la veille sur Java.
** Documentation officielle
- [[https://docs.oracle.com/javase/tutorial/][Java tutorials]]
- [[https://docs.oracle.com/javase/8/docs/api/][Javadoc]], documentation de la bibliothèque standard

** Sur le web
- [[https://www.baeldung.com/][Baeldung]]
- [[https://www.vogella.com/tutorials/java.html][Vogella]]
- [[https://dzone.com/java-jdk-development-tutorials-tools-news/list][Dzone]]


